<!doctype html><html class="theme-next muse use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta property="og:type" content="website"><meta property="og:title" content="Zehao's Blog"><meta property="og:url" content="https://www.93html.com/index.html"><meta property="og:site_name" content="Zehao's Blog"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Zehao's Blog"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Muse",sidebar:{position:"left",display:"hide"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"博主"}}</script><title>Zehao's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container one-collumn sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Zehao's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">虽千万里 吾往矣</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section">归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/12/27/Webpack-基本概念/" itemprop="url">Webpack 基本概念</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-12-27T12:40:10+08:00" content="2016-12-27">2016-12-27 </time></span><span class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>Webpack 的核心概念可以分为：Entry point，Chunk，Module，这三者之间的关系可以用一张官方图片来解释：</p><p><img src="https://webpack.github.io/assets/HMR.svg" alt="generated update chunks"></p><h2 id="Entry-point"><a href="#Entry-point" class="headerlink" title="Entry point"></a><a href="http://webpack.github.io/docs/configuration.html#entry" target="_blank" rel="external">Entry point</a></h2><p>Entry point 是比较好理解的，指的是程序的入口文件，也是 Webpack 解析依赖的入口文件，Entry point 可以设置单入口或者多入口，以一个最简单的入口文件为例</p><pre><code class="js">// index.js
var a = require(&#39;./a&#39;);

a();
</code></pre><h2 id="Chunk"><a href="#Chunk" class="headerlink" title="Chunk"></a>Chunk</h2><p>Chunk 指的是经过编译后的代码包，Webpack 会将每个由用户定义的模块，转换成 Chunk 的形式，这些 Chunk 最终汇总到一个数组中，供运行时调用</p><pre><code class="js">// 原始的 a.js
module.export = function() {
    alert(&#39;Hello&#39;);
};

// 经过编译后的 chunk
function(module, exports, __webpack_require__) {
    &#39;use strict&#39;;

    module.exports = function () {
        alert(&#39;Hello&#39;);
    };
}
</code></pre><p>这里 Chunk 转换的过程中还会调用 Loaders，Loaders 的作用是将非 JS 资源转换成字符串，并且提供运行时解析这些字符串的功能</p><p>最终 Webpack 为模块代码外面包了一层 function，并且注入了 <code>module</code>、<code>exports</code> 和 <code>__webpack_require__</code> 3个参数，这些参数的定义看下文代码示例中的 <code>require</code> 方法</p><h2 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h2><p>Module 是拥有如下结构的一个 <code>Object</code>，它的作用是保存 Chunk 的信息</p><pre><code class="js">{
    exports: {},
    id: 3,
    loaded: false
}
</code></pre><p>一个 Module 对应一个 Chunk，<code>exports</code> 保存了 Chunk 中输出的内容，<code>id</code> 为 Chunk 的索引，<code>loaded</code> 记录 Chunk 是否加载</p><h2 id="它们是如何工作的？"><a href="#它们是如何工作的？" class="headerlink" title="它们是如何工作的？"></a>它们是如何工作的？</h2><p>Webpack Runtime 的一个简单实现</p><pre><code class="js">const chunks = [
    function(module, exports, __webpack_require__) {
        &#39;use strict&#39;;

        module.exports = function () {
            alert(&#39;Hello&#39;);
        };
    },
    ...
];

function require(id) {
    // 定义 module 对象
    var module = {
        exports: {},
        id: moduleId,
        loaded: false
    };

    // 执行 chunk
    chunks[id].call(module.exports, module, module.exports, require);

    module.loaded = true;

    // 返回 module 的输出部分
    return module.exports;
}

// entry point
var a = require(0); // 这里的 require(&#39;./a&#39;) 会被替换为 chunk 的索引

a();
//
</code></pre></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/12/24/大幅提升-React-性能的6个建议/" itemprop="url">大幅提升 React 性能的6个建议</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-12-24T14:19:21+08:00" content="2016-12-24">2016-12-24 </time></span><span class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>React 在不做任何优化的情况下性能也非常好，然而通过一些小小的优化，可以让性能进一步提升，通过以下这6条建议，可以数十倍加快渲染速度</p><h2 id="设置-NODE-ENV-为-Production"><a href="#设置-NODE-ENV-为-Production" class="headerlink" title="设置 NODE_ENV 为 Production"></a>设置 NODE_ENV 为 Production</h2><p>React 在开发环境下，有完整的警告和错误检查，但它们不是为生产环境准备的，如果你看过 React 的源码，你会看到很多 <code>if (process.env.NODE_ENV != &#39;production&#39;)</code>，这些代码对于最终用户是不需要的，而且访问 <code>process.env.NODE_ENV</code> 会非常慢，对于生产环境而言，完全可以移除这些代码</p><p>如果你使用 <a href="https://webpack.github.io/" target="_blank" rel="external">Webpack</a>，你可以使用 <a href="https://webpack.github.io/docs/list-of-plugins.html#defineplugin" target="_blank" rel="external">DefinePlugin</a> 来替换 <code>process.env.NODE_ENV</code> 为 ‘production’，然后使用 <a href="https://webpack.github.io/docs/list-of-plugins.html#uglifyjsplugin" target="_blank" rel="external">UglifyJsPlugin</a> 移除这些不会执行的代码</p><pre><code class="js">// webpack.config.js
...
plugins: [
    new webpack.DefinePlugin({
        &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;)
    }),
    new webpack.optimize.UglifyJsPlugin({
        compress: {
            warnings: false
        }
    })
]
...
</code></pre><h2 id="React-15-的渲染速度比-0-14-快约-25"><a href="#React-15-的渲染速度比-0-14-快约-25" class="headerlink" title="React 15 的渲染速度比 0.14 快约 25%"></a>React 15 的渲染速度比 0.14 快约 25%</h2><p>在 <a href="https://facebook.github.io/react/blog/2016/04/07/react-v15.html" target="_blank" rel="external">React 15 的更新</a>中非常重要的一项是，使用在现代化浏览器中性能更好的 <code>document.createElement</code> 替换 <code>innerHTML</code>，这一改动也意味着 React 将不再支持 IE8</p><h2 id="Babel-Constant-和-Inline-Elements-转换"><a href="#Babel-Constant-和-Inline-Elements-转换" class="headerlink" title="Babel Constant 和 Inline Elements 转换"></a>Babel Constant 和 Inline Elements 转换</h2><p>Babel 为开发者们提供了 <a href="http://babeljs.io/docs/plugins/transform-react-constant-elements/" target="_blank" rel="external">React Constant Elements</a> 和 <a href="https://babeljs.io/docs/plugins/transform-react-inline-elements/" target="_blank" rel="external">React Inline Elements</a>，这两款插件能够在编译阶段将代码转换成更高效的形式，注意仅将它们用于生产环境</p><h2 id="封装集合渲染为独立组件"><a href="#封装集合渲染为独立组件" class="headerlink" title="封装集合渲染为独立组件"></a>封装集合渲染为独立组件</h2><p>这一点在循环渲染集合组件时尤其重要，React 在渲染大型集合是性能十分糟糕，原因是 React 会在每次更新中全部重新渲染，因此建议将渲染集合的部分装为独立的组件渲染</p><pre><code class="js">// Bad
class MyComponent extends Component {
    render() {
        const {todos, user} = this.props;
        return (&lt;div&gt;
            {user.name}
            &lt;ul&gt;
                {todos.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt;)}
            &lt;/ul&gt;
        &lt;/div&gt;)
    }
}
</code></pre><pre><code class="js">// Good
// 当 user.name 更新时，列表不会重新渲染
class MyComponent extends Component {
    render() {
        const {todos, user} = this.props;
        return (&lt;div&gt;
            {user.name}
            &lt;TodosView todos={todos} /&gt;
        &lt;/div&gt;)
    }
}

class TodosView extends Component {
    render() {
        const {todos} = this.props;
        return (&lt;ul&gt;
            {todos.map(todo =&gt; &lt;TodoView todo={todo} key={todo.id} /&gt;)}
        &lt;/ul&gt;)
    }
}
</code></pre><h2 id="尽早绑定方法"><a href="#尽早绑定方法" class="headerlink" title="尽早绑定方法"></a>尽早绑定方法</h2><p>在 render() 中绑定的方法应该尽早声明，而不是在渲染时定义</p><pre><code class="js">// Bad
render() {
    return &lt;MyWidget onClick={() =&gt; { alert(this.state.text) }} /&gt;
}
</code></pre><pre><code class="js">// Good
constructor() {
    this.handleClick = this.handleClick.bind(this);
}

handleClick() {
    alert(this.state.text);
}

render() {
    return &lt;MyWidget onClick={this.handleClick} /&gt;
}
</code></pre><h2 id="不变组件禁用更新"><a href="#不变组件禁用更新" class="headerlink" title="不变组件禁用更新"></a>不变组件禁用更新</h2><p>对于不需要更新的组件，可以在 <code>shouldComponentUpdate()</code> 中 <code>return false</code>，或者使用 <a href="https://facebook.github.io/react/docs/components-and-props.html" target="_blank" rel="external">Stateless Component</a></p><pre><code class="js">// Bad
class Logo extends Component {
    render() {
        return &lt;div&gt;&lt;img src=&#39;logo.png&#39; /&gt;&lt;/div&gt;;
    }
}
</code></pre><pre><code class="js">// Good
class Logo extends Component {
    shouldComponentUpdate() {
        return false;
    }

    render() {
        return &lt;div&gt;&lt;img src=&#39;logo.png&#39; /&gt;&lt;/div&gt;;
    }
}

// or Stateless Component
const Logo = () =&gt; &lt;div&gt;&lt;img src=&#39;logo.png&#39; /&gt;&lt;/div&gt;;
</code></pre><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5><ul><li><a href="https://github.com/markerikson/react-redux-links/blob/master/react-performance.md" target="_blank" rel="external">React performance</a></li><li><a href="https://reactjsnews.com/how-to-make-your-react-apps-10x-faster" target="_blank" rel="external">How to Make Your React Apps 15x Faster</a></li><li><a href="https://daveceddia.com/avoid-bind-when-passing-props/" target="_blank" rel="external">Avoid bind when passing props</a></li><li><a href="https://mobxjs.github.io/mobx/best/react-performance.html" target="_blank" rel="external">Optimizing rendering React components</a></li></ul></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/12/19/Webpack-动态加载/" itemprop="url">Webpack 动态加载</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-12-19T15:28:17+08:00" content="2016-12-19">2016-12-19 </time></span><span class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>在 Webpack 的使用过程中，一开始人们都习惯了将一切东西 <code>import</code> 进来，这样做很符合逻辑，但是随着业务量不断增加，会发现 bundle 的体积不断增大，导致首次加载非常缓慢，比如我有一个路由映射的对象是这样写的</p><pre><code class="javascript">...
&#39;/shop&#39;: require(&#39;components/Shop/Home&#39;),
&#39;/shop/goods&#39;: require(&#39;components/Shop/Goods&#39;),
&#39;/shop/goods-detail&#39;: require(&#39;components/Shop/Detail&#39;),
...
</code></pre><p>最终这些模块都会被打包进 bundle，而我想要的效果是每次只加载当前路由对应的模块，这一点 Webpack 已经为我们提供了解决方案</p><h2 id="Code-Splitting"><a href="#Code-Splitting" class="headerlink" title="Code Splitting"></a><a href="http://webpack.github.io/docs/code-splitting.html" target="_blank" rel="external">Code Splitting</a></h2><p>Code Splitting 的做法是在代码中定义分离点，在这个分离点内依赖的模块，在编译阶段会被单独打包，并在运行时动态加载进来</p><p>Code Splitting 支持 AMD 和 CommonJs 两种风格</p><h4 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs:"></a>CommonJs:</h4><pre><code class="js">// 参数一 module-a, module-b 作为依赖会首先加载
// 参数二是 callback 函数，参数 require 可以加载模块
// 参数三是为这个分离点模块命名
// 最终 module-a module-b module-c 会被打包成一个文件
require.ensure([&quot;module-a&quot;, &quot;module-b&quot;], function(require) {
    var a = require(&quot;module-a&quot;);
    var c = require(&quot;module-c&quot;);
    // ...
}, &#39;bundle&#39;);
</code></pre><p>注意：require.ensure 的模块只会被下载下来，不会被执行，只有在回调函数使用require(模块名)后，这个模块才会被执行。</p><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD:"></a>AMD:</h4><pre><code class="js">// 参数一同样会首先被加载，并作为参数传入 callback
require([&quot;module-a&quot;, &quot;module-b&quot;], function(a, b) {
    var c = require(&quot;module-c&quot;);
    // ...
});
</code></pre><p>注意 callback 是必须的</p><p>当代码运行时 Webpack 会在文档中动态插入</p><pre><code class="js">&lt;script type=&quot;text/javascript&quot; charset=&quot;utf-8&quot; async=&quot;&quot; src=&quot;1.bundle.js&quot;&gt;&lt;/script&gt;
</code></pre><p>Webpack 只会当代码运行时才去加载，假如说我定义了多个分离点</p><pre><code class="js">require.ensure([], function(require) {
    var a = require(&quot;module-a&quot;);
});

if (false) {
    require.ensure([], function(require) {
        var a = require(&quot;module-b&quot;);
    });
}
</code></pre><p>module-b 是不会被加载，利用这个功能，我们将那个路由映射修改一下</p><pre><code class="js">...
&#39;/shop&#39;: callback =&gt; require.ensure([], function(require) {
    callback(require(&quot;components/Shop/Home&quot;));
}),
&#39;/shop/goods&#39;: callback =&gt; require.ensure([], function(require) {
    callback(require(&quot;components/Shop/Goods&quot;));
}),
&#39;/shop/goods-detail&#39;: callback =&gt; require.ensure([], function(require) {
    callback(require(&quot;components/Shop/Detail&quot;));
}),
...
</code></pre><p>在路由解析的代码也需要修改一下</p><pre><code class="js">// 原来的同步获取模块写法
var module = router.match(location.href);
render(module);

// 现使用异步方法获得
router.match(location.href, function(module) {
    render(module);
});
</code></pre><p>由于 require.ensure 写法过于冗长，我曾想把这段封装起来，但是发现是不可行的，require.ensure 方法十分特殊，必须以字符串作为参数</p><pre><code class="js">// 以下方式无效！
function getModule(path, callback) {
    require.ensure([], function(require) {
        callback(require(path));
    });
}

...
&#39;/shop&#39;: callback =&gt; getModule(&quot;components/Shop/Home&quot;, callback),
...
</code></pre><h2 id="请求路经配置"><a href="#请求路经配置" class="headerlink" title="请求路经配置"></a>请求路经配置</h2><p>根据 Code Splitting 的原理，模块请求的默认 hostname 是和当前页面相同的，比如访问 <code>http://www.x.com/</code> 那么模块的请求就是 <code>http://www.x.com/1.bundle.js</code></p><p>如果要设置在别的域获取，可以在 <code>output.publicPath</code> 中设置</p><pre><code class="js">...
output: {
    publicPath: &#39;http://cdn.x.com/&#39;
}
...
</code></pre><p>那么请求就变成了 <code>http://cdn.x.com/1.bundle.js</code></p><p>这是一种在编译阶段配置的方法，如果路经需要到运行时才能确定，可以在入口文件中设置</p><pre><code class="js">__webpack_public_path__ = `http://${config.host}:/`
</code></pre><p>详细用法参考 <a href="https://webpack.github.io/docs/configuration.html#output-path" target="_blank" rel="external">https://webpack.github.io/docs/configuration.html#output-path</a></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2016/12/15/一个新的开始/" itemprop="url">一个新的开始</a></h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2016-12-15T23:03:43+08:00" content="2016-12-15">2016-12-15 </time></span><span class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/随笔/" itemprop="url" rel="index"><span itemprop="name">随笔</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>来到了这个新的博客，想着得写一篇具有纪念意义的文章，想来想去也不知从何说起，我这个人的叙述能力一般，写东西提起笔半天也下不去，最初有开博客的想法也是为了锻炼一下文笔，然而其实并没有写多少东西，即使写也是类似于笔记之类的，没什么语言组织在里面。最近由于服务器到期，也不想掏这个钱了，干脆弄了个 Hexo + Github Pages。在导入之前博客的时候发现页面格式变得乱七八糟，有些图片也挂了，而且写的内容现在看看也觉得幼齿的很，干脆统统不要，一切都从头开始</p><p>关于写博客这件事情呢，我认为对学习掌握新知识是特别有帮助的，最重要的2个作用是</p><ul><li>把所学到的知识转换成自己的文字，本身是一个对知识的整理、思考、内化的过程</li><li>人脑容量有限，趁想法还热乎的时候记录下来，分门别类管理，便于日后查阅</li></ul><p>博客还有一个重要的作用是 <strong>装逼</strong>，虽说目前没几个人能看到这些文字，但是未来总有那么个人无意走进来，从而发现我默默耕耘着的小天地，发自内心的为我点👍，对我来说也就足够了</p><p>当然写博客最重要的是坚持，纵观我的博客史，发现自己并不是那么勤奋，从3年前开始，多的时候也就一两个月写一篇，有的时候半年才写一篇，想想当初设定的每星期写一篇的目标相去甚远，人呐，骨子里都是懒汉，但是到了一定的岁数，会发现坚持的力量有多么强大，滴水穿石的道理不是嘴上说说就懂的，以前总觉得时间多的是，可是时间哪天不是24小时，何时多出来过，不去珍惜到头来荒废的是自己，这次重开 blog，我也不给自己定什么目标了，平时多加以思考和总结，努力克服内心的懒汉，未来可能还是光明的</p><p>关于这个博客，使用的是 <a href="https://hexo.io" target="_blank" rel="external">Hexo</a>，之前完全没接触过静态 blog，经人推荐后发现特别简洁，不需要部署一堆东西，也没有后台界面，你需要做的就是纯粹的专注于写作，这种返璞归真的体验真的棒极了，而且 Hexo 是开源的，想要什么直接自己折腾，对于程序员特别友好。站点是托管在 Github Pages，全球 CDN 分布，服务器方面的一概不用操心。HTTPs 证书用的是 <a href="https://www.cloudflare.com/" target="_blank" rel="external">Cloudflare</a> 提供的免费服务，反正只要他们家还开着，我就可以一直用下去……</p><p>2016 年最后剩下半个月，也快要到我的生日了，身上的种种无知、浮躁会不会随着年龄的增长而减少一点呢？未来的道路又将会指引我通向何处？幸福究竟对我来说是什么样的？只有一点我是可以确认的，眼前的这条道路是真实的，一步一个脚印走下去，最终这些疑问都会得到答案，所以，整理好思绪，收拾好心情，如同这个崭新的博客，迎接未来的人生吧。<strong>虽千万里 吾往矣！</strong></p></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Zehao Zhang"><p class="site-author-name" itemprop="name">Zehao Zhang</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives"><span class="site-state-item-count">4</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">2</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">2</span> <span class="site-state-item-name">标签</span></div></nav><div class="links-of-author motion-element"></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2016</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Zehao Zhang</span> <a href="http://www.miibeian.gov.cn/" target="_blank">沪ICP备16039653号</a></div><div class="powered-by">由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script></body></html>