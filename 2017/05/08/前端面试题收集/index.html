<!doctype html><html class="theme-next muse use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1"><meta name="description" content="常见前端面试题整理贴"><meta property="og:type" content="article"><meta property="og:title" content="前端面试题收集"><meta property="og:url" content="https://www.93html.com/2017/05/08/前端面试题收集/index.html"><meta property="og:site_name" content="Zehao&#39;s Blog"><meta property="og:description" content="常见前端面试题整理贴"><meta property="og:locale" content="zh-Hans"><meta property="og:updated_time" content="2017-05-18T14:32:14.000Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="前端面试题收集"><meta name="twitter:description" content="常见前端面试题整理贴"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Muse",sidebar:{position:"left",display:"hide"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"博主"}}</script><title>前端面试题收集 | Zehao's Blog</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-77777540-1","auto"),ga("send","pageview")</script><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Zehao's Blog</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">虽千万里 吾往矣</p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section">首页</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section">归档</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline">前端面试题收集</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time itemprop="dateCreated" datetime="2017-05-08T21:43:47+08:00" content="2017-05-08">2017-05-08 </time></span><span class="post-category">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/技术/" itemprop="url" rel="index"><span itemprop="name">技术</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><p>常见前端面试题整理贴<br><a id="more"></a></p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="js的继承实现"><a href="#js的继承实现" class="headerlink" title="js的继承实现"></a>js的继承实现</h3><p>JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象的原型的原型，依此层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。</p><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h4><h5 id="构造器方法"><a href="#构造器方法" class="headerlink" title="构造器方法"></a>构造器方法</h5><p>构造器其实就是一个普通的函数。当使用 new 操作符 来作用这个函数时，它就可以被称为构造方法（构造函数）。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Graph</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.vertices = [];</div><div class="line">  <span class="keyword">this</span>.edges = [];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Graph.prototype = &#123;</div><div class="line">  addVertex: <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.vertices.push(v);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> g = <span class="keyword">new</span> Graph();</div><div class="line"><span class="comment">// g是生成的对象,他的自身属性有'vertices'和'edges'.</span></div><div class="line"><span class="comment">// 在g被实例化时,g.[[Prototype]]指向了Graph.prototype.</span></div></pre></td></tr></table></figure><p></p><h5 id="Object-create-es5"><a href="#Object-create-es5" class="headerlink" title="Object.create (es5)"></a>Object.create (es5)</h5><p>ECMAScript 5 中引入了一个新方法：Object.create()。可以调用这个方法来创建一个新对象。新对象的原型就是调用 create 方法时传入的第一个参数：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="comment">// a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.create(a);</div><div class="line"><span class="comment">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(b.a); <span class="comment">// 1 (继承而来)</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> c = <span class="built_in">Object</span>.create(b);</div><div class="line"><span class="comment">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> d = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</div><div class="line"><span class="comment">// d ---&gt; null</span></div><div class="line"><span class="built_in">console</span>.log(d.hasOwnProperty); <span class="comment">// undefined, 因为d没有继承Object.prototype</span></div></pre></td></tr></table></figure><p></p><h5 id="class-es6"><a href="#class-es6" class="headerlink" title="class (es6)"></a>class (es6)</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(height, width) &#123;</div><div class="line">    <span class="keyword">this</span>.height = height;</div><div class="line">    <span class="keyword">this</span>.width = width;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Polygon</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(sideLength) &#123;</div><div class="line">    <span class="keyword">super</span>(sideLength, sideLength);</div><div class="line">  &#125;</div><div class="line">  get area() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.height * <span class="keyword">this</span>.width;</div><div class="line">  &#125;</div><div class="line">  set sideLength(newLength) &#123;</div><div class="line">    <span class="keyword">this</span>.height = newLength;</div><div class="line">    <span class="keyword">this</span>.width = newLength;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> square = <span class="keyword">new</span> Square(<span class="number">2</span>);</div></pre></td></tr></table></figure><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。<br>hasOwnProperty 是 JavaScript 中唯一一个只涉及对象自身属性而不会遍历原型链的方法。</p><h3 id="js的闭包"><a href="#js的闭包" class="headerlink" title="js的闭包"></a>js的闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">闭包是指那些能够访问独立(自由)变量的函数 (变量在本地使用，但定义在一个封闭的作用域中)。</div><div class="line">换句话说，这些函数可以“记忆”它被创建时候的环境。</div></pre></td></tr></table></figure><p>闭包是指能够访问在封闭作用于内的变量的函数，这些函数可以保存它们被创建时的环境。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> name = <span class="string">"Mozilla"</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(name);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> displayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myFunc = makeFunc();</div><div class="line">myFunc();</div></pre></td></tr></table></figure><p></p><h4 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h4><ul><li><p>访问私有属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> name = <span class="string">'fooname'</span>;</div><div class="line">      <span class="keyword">var</span> age = <span class="number">12</span>;</div><div class="line">      <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">          <span class="keyword">return</span> name;</div><div class="line">      &#125;;</div><div class="line">      <span class="keyword">this</span>.getAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">          <span class="keyword">return</span> age;</div><div class="line">      &#125;;</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</div><div class="line"></div><div class="line">  foo.name;        <span class="comment">//  =&gt; undefined</span></div><div class="line">  foo.age;         <span class="comment">//  =&gt; undefined</span></div><div class="line">  foo.getName();   <span class="comment">//  =&gt; 'fooname'</span></div><div class="line">  foo.getAge();    <span class="comment">//  =&gt; 12</span></div></pre></td></tr></table></figure></li><li><p>在内存中维持变量：如果缓存数据、柯里化。</p></li></ul><h4 id="性能问题"><a href="#性能问题" class="headerlink" title="性能问题"></a>性能问题</h4><p>需要注意的，由于闭包内的部分资源无法自动释放，容易造成内存泄露</p><h3 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”;"></a>“use strict”;</h3><h4 id="声明方式"><a href="#声明方式" class="headerlink" title="声明方式"></a>声明方式</h4><ul><li>script 声明</li><li><p>function 声明</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><h5 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h5><p>如果代码中使用”use strict”开启了严格模式,则下面的情况都会在脚本运行之前抛出SyntaxError异常:</p></li><li><p>八进制语法:var n = 023和var s = “\047” (数字前不能有0)</p></li><li>with语句</li><li>使用delete删除一个变量名(而不是属性名):delete myVariable</li><li>使用eval或arguments作为变量名或函数名</li><li>使用未来保留字(也许会在ECMAScript 6中使用):implements, interface, let, package, private, protected, public, static,和yield作为变量名或函数名</li><li>在语句块中使用函数声明:if(a&lt;b){ function f(){} }</li><li>对象字面量中使用两个相同的属性名:{a: 1, b: 3, a: 7}</li><li>函数形参中使用两个相同的参数名:function f(a, b, b){}</li></ul><h4 id="语义差异"><a href="#语义差异" class="headerlink" title="语义差异"></a>语义差异</h4><h5 id="函数调用中的this"><a href="#函数调用中的this" class="headerlink" title="函数调用中的this"></a>函数调用中的this</h5><p>在普通的函数调用f()中,this的值会指向全局对象.在严格模式中,this的值会指向undefined.当函数通过call和apply调用时,如果传入的thisvalue参数是一个null和undefined除外的原始值(字符串,数字,布尔值),则this的值会成为那个原始值对应的包装对象,如果thisvalue参数的值是undefined或null,则this的值会指向全局对象.在严格模式中,this的值就是thisvalue参数的值,没有任何类型转换.</p><h5 id="arguments对象属性不与对应的形参变量同步更新"><a href="#arguments对象属性不与对应的形参变量同步更新" class="headerlink" title="arguments对象属性不与对应的形参变量同步更新"></a>arguments对象属性不与对应的形参变量同步更新</h5><p>在非严格模式中,修改arguments对象中某个索引属性的值,和这个属性对应的形参变量的值也会同时变化,反之亦然.这会让JavaScript的代码混淆引擎让代码变得更难读和理解。在严格模式中arguments 对象会以形参变量的拷贝的形式被创建和初始化，因此 arguments 对象的改变不会影响形参。</p><h5 id="eval相关的区别"><a href="#eval相关的区别" class="headerlink" title="eval相关的区别"></a>eval相关的区别</h5><p>在严格模式中,eval不会在当前的作用域内创建新的变量.另外,传入eval的字符串参数也会按照严格模式来解析.你需要全面测试来确保没有代码收到影响。另外，如果你并不是为了解决一个非常实际的解决方案中，尽量不要使用eval。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h4><p>在全局运行上下文中（在任何函数体外部），this指代全局对象，无论是否在严格模式下。</p><h4 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h4><p>在函数内部，this的值取决于函数是如何调用的。</p><h5 id="直接调用"><a href="#直接调用" class="headerlink" title="直接调用"></a>直接调用</h5><ul><li>非严格模式 window</li><li>严格模式 如果this未被执行的上下文环境定义，那么它将会默认为undefined。</li></ul><h4 id="对象方法中的-this"><a href="#对象方法中的-this" class="headerlink" title="对象方法中的 this"></a>对象方法中的 this</h4><p>对象方法中的this，指向调用该函数的对象（就近原则）</p><h4 id="构造函数中的-this"><a href="#构造函数中的-this" class="headerlink" title="构造函数中的 this"></a>构造函数中的 this</h4><p>当一个函数被作为一个构造函数来使用（使用new关键字），它的this与即将被创建的新对象绑定。</p><h4 id="call-apply"><a href="#call-apply" class="headerlink" title="call / apply"></a>call / apply</h4><p>绑定到一个指定的对象上</p><h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><p>f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>在一个对象上触发某类事件（比如单击onclick事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。</p><h4 id="阻止继续冒泡"><a href="#阻止继续冒泡" class="headerlink" title="阻止继续冒泡"></a>阻止继续冒泡</h4><p>stopPropagation()</p><h3 id="AMD-CMD-UMD"><a href="#AMD-CMD-UMD" class="headerlink" title="AMD/CMD/UMD"></a>AMD/CMD/UMD</h3><ol><li>对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码：<br>在 RequireJS 里，模块有多种书写格式，推荐的是：<br>define([“./a”, “./b”], function(a, b) {<br>a.doSomething();<br>b.doSomething();<br>});<br>在 SeaJS 里，模块只有一种书写格式：<br>define(function(require, exports, module) {<br>require(“./a”).doSomething();<br>require(“./b”).doSomething();<br>});</li></ol><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>里到外 padding border margin</p><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>属性用于更改用于计算元素宽度和高度的默认的 CSS 盒子模型。可以使用此属性来模拟不正确支持CSS盒子模型规范的浏览器的行为。</p><h5 id="content-box"><a href="#content-box" class="headerlink" title="content-box"></a>content-box</h5><p>默认值，标准盒子模型。 width 与 height 只包括内容的宽和高， 不包括边框（border），内边距（padding），外边距（margin）。</p><h5 id="border-box"><a href="#border-box" class="headerlink" title="border-box"></a>border-box</h5><p>width 和 height 属性包括内容，内边距和边框，但不包括外边距。</p><h3 id="position有哪些属性，各自是什么特点？"><a href="#position有哪些属性，各自是什么特点？" class="headerlink" title="position有哪些属性，各自是什么特点？"></a>position有哪些属性，各自是什么特点？</h3><h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>该关键字指定元素使用正常的布局行为，即元素在文档流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效。</p><h5 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h5><p>该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 未定义对 table, 元素应用的效果。</p><h5 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h5><p>不为元素预留空间，通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><h5 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h5><p>不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的栈上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。</p><h5 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h5><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky 对 table 元素的效果与 position: relative 相同。</p><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#wrapper</span> &#123;</div><div class="line">    <span class="attribute">display</span>: table;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-id">#cell</span> &#123;</div><div class="line">    <span class="attribute">display</span>: table-cell;</div><div class="line">    <span class="attribute">vertical-align</span>: middle;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#content</span> &#123;</div><div class="line">    <span class="attribute">position</span>: relative;</div><div class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</div><div class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-50%);</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="行高（单行文本）"><a href="#行高（单行文本）" class="headerlink" title="行高（单行文本）"></a>行高（单行文本）</h4><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#content</span>&#123;</div><div class="line">    <span class="attribute">display</span>:flex;</div><div class="line">    <span class="attribute">align-item</span>: center</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="JS-1"><a href="#JS-1" class="headerlink" title="JS"></a>JS</h4><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><p><a href="http://www.cnblogs.com/imwtr/p/4441741.html" target="_blank" rel="external">http://www.cnblogs.com/imwtr/p/4441741.html</a></p><h3 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a>flex</h3><p><a href="http://www.cnblogs.com/imwtr/p/4441741.html" target="_blank" rel="external">http://www.cnblogs.com/imwtr/p/4441741.html</a></p><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p><a href="https://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="external">https://css-tricks.com/snippets/css/complete-guide-grid/</a></p><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="Style标签放置的最佳位置"><a href="#Style标签放置的最佳位置" class="headerlink" title="Style标签放置的最佳位置"></a>Style标签放置的最佳位置</h3><p>head 里，提前加载样式<br>w3c不建议放在body中，新增的style标签的“scoped”属性（兼容性不行，只有FF）</p><h3 id="常见行内元素和块级元素"><a href="#常见行内元素和块级元素" class="headerlink" title="常见行内元素和块级元素"></a>常见行内元素和块级元素</h3><p>行内 ： b, em, strong,<br>a, br, img, span, sub, sup<br>button, input, label, select, textarea</p><p>块级元素：canvas，div，dl，footer，form，h1，header，hr，p，pre，section，table，ul，li</p><h3 id="HTML5-新增标签"><a href="#HTML5-新增标签" class="headerlink" title="HTML5 新增标签"></a>HTML5 新增标签</h3><p>article, audio, video, canvas, footer, header, nav, section</p><h3 id="Doctype"><a href="#Doctype" class="headerlink" title="Doctype"></a>Doctype</h3><p>&lt;!DOCTYPE&gt; 告知 浏览器 当前的 HTML (或 XML) 文档是哪一个版本. Doctype 是一条 声明, 而不是一个 标签; 也可以把它叫做 “文档类型声明”, 或 简称为 “DTD”.</p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="IE和Chrome事件模型的区别"><a href="#IE和Chrome事件模型的区别" class="headerlink" title="IE和Chrome事件模型的区别"></a>IE和Chrome事件模型的区别</h3><p>Chrome 捕获=&gt;目标=&gt;冒泡<br>IE 目标=&gt;冒泡</p><h3 id="cookie和session区别"><a href="#cookie和session区别" class="headerlink" title="cookie和session区别"></a>cookie和session区别</h3><p>1，session 在服务器端，cookie 在客户端（浏览器）<br>2，session 默认被存在在服务器的一个文件里（不是内存）<br>3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id）<br>4，session 可以放在 文件、数据库、或内存中都可以。<br>5，用户验证这种场合一般会用 session</p><h3 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h3><h4 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h4><p>Cache-Control:public, max-age=31536000</p><h4 id="HTML5-manifest"><a href="#HTML5-manifest" class="headerlink" title="HTML5 manifest"></a>HTML5 manifest</h4><h4 id="localStorage"><a href="#localStorage" class="headerlink" title="localStorage"></a>localStorage</h4><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="处理跨域的方法"><a href="#处理跨域的方法" class="headerlink" title="处理跨域的方法"></a>处理跨域的方法</h3><h4 id="Iframe-document-domain"><a href="#Iframe-document-domain" class="headerlink" title="Iframe + document.domain"></a>Iframe + document.domain</h4><p>原理：相同主域名不同子域名下的页面，可以设置document.domain让它们同域<br>限制：同域document提供的是页面间的互操作，需要载入iframe页面</p><h4 id="有src的标签-统计代码"><a href="#有src的标签-统计代码" class="headerlink" title="有src的标签(统计代码)"></a>有src的标签(统计代码)</h4><p>原理：所有具有src属性的HTML标签都是可以跨域的，包括img, script<br>限制：需要创建一个DOM对象，只能用于GET方法</p><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>原理：script是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数。<br>限制：需要创建一个DOM对象并且添加到DOM树，只能用于GET方法<br>.getJSON与.get的区别是前者会把responseText转换为JSON，而且当URL具有callback参数时， jQuery将会把它解释为一个JSONP请求，创建一个script标签来完成该请求。</p><h4 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h4><p>原理：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求<br>限制：浏览器需要支持HTML5，可以支持POST，PUT等方法</p><h3 id="常见HTTP状态码"><a href="#常见HTTP状态码" class="headerlink" title="常见HTTP状态码"></a>常见HTTP状态码</h3><ol><li>1xx消息</li><li>2xx成功</li><li>3xx重定向</li><li>4xx客户端错误</li><li>5xx服务器错误<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3>GET在浏览器回退时是无害的，而POST会再次提交请求。<br>GET产生的URL地址可以被Bookmark，而POST不可以。<br>GET请求会被浏览器主动cache，而POST不会，除非手动设置。<br>GET请求只能进行url编码，而POST支持多种编码方式。<br>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。<br>GET请求在URL中传送的参数是有长度限制的，而POST么有。<br>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。<br>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。<br>GET参数通过URL传递，POST放在Request body中。</li></ol><p>HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，也就是说，GET/POST都是TCP链接。GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。</p><p>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</p><p>GET产生一个TCP数据包；POST产生两个TCP数据包。</p><p>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；<br>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</p><h3 id="url请求的过程"><a href="#url请求的过程" class="headerlink" title="url请求的过程"></a>url请求的过程</h3><p>浏览器查找域名的 IP 地址<br>这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…<br>浏览器向 web 服务器发送一个 HTTP 请求 4. 服务器的永久重定向响应（从 <a href="http://example.com" target="_blank" rel="external">http://example.com</a> 到 <a href="http://www.example.com）" target="_blank" rel="external">http://www.example.com）</a><br>浏览器跟踪重定向地址<br>服务器处理请求<br>服务器返回一个 HTTP 响应<br>浏览器显示 HTML<br>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）<br>浏览器发送异步请求</p><h2 id="服务器技术"><a href="#服务器技术" class="headerlink" title="服务器技术"></a>服务器技术</h2><h3 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h3><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="antdesign"><a href="#antdesign" class="headerlink" title="antdesign"></a>antdesign</h3><h3 id="React的diff原理和组件化思想"><a href="#React的diff原理和组件化思想" class="headerlink" title="React的diff原理和组件化思想"></a>React的diff原理和组件化思想</h3><h3 id="state-props"><a href="#state-props" class="headerlink" title="state / props"></a>state / props</h3><p>props不变的，state变的。</p><h3 id="f7优缺点"><a href="#f7优缺点" class="headerlink" title="f7优缺点"></a>f7优缺点</h3><h3 id="node版本的区别"><a href="#node版本的区别" class="headerlink" title="node版本的区别"></a>node版本的区别</h3><h3 id="angularjs-脏检查"><a href="#angularjs-脏检查" class="headerlink" title="angularjs 脏检查"></a>angularjs 脏检查</h3><p>Angular将双向绑定转换为一堆watch表达式，然后递归检查这些watch表达式的结果是否变化。如果变化，则执行相应的watcher函数。等到model值不再变化，也就不会再有watch函数被触发，则一个digest循环结束。<br>$watch: 监听scope model变化<br>$apply: 触发“脏检查”<br>$digest: 内部函数，执行脏检查。 digest循环包括2个while循环:<br>处理$evalAsync的异步运算队列<br>处理$watch的wathers队列</p></div><div></div><div></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/05/06/Javascript 浮点数精度问题/" rel="next" title="Javascript 浮点数精度问题"><i class="fa fa-chevron-left"></i> Javascript 浮点数精度问题</a></div><div class="post-nav-prev post-nav-item"><a href="/2017/05/18/我的失败主义/" rel="prev" title="我的失败主义">我的失败主义 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview">站点概览</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Zehao Zhang"><p class="site-author-name" itemprop="name">Zehao Zhang</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">16</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><span class="site-state-item-count">3</span> <span class="site-state-item-name">分类</span></div><div class="site-state-item site-state-tags"><span class="site-state-item-count">7</span> <span class="site-state-item-name">标签</span></div></nav><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/93html" target="_blank" title="GitHub">GitHub </a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/zhang-ze-hao-45/activities" target="_blank" title="Zhihu">Zhihu </a></span><span class="links-of-author-item"><a href="http://weibo.com/u/2157997197/" target="_blank" title="Weibo">Weibo </a></span><span class="links-of-author-item"><a href="http://www.linkedin.com/in/%E6%B3%BD%E8%B1%AA-%E5%BC%A0-792887a1" target="_blank" title="LinkedIn">LinkedIn </a></span><span class="links-of-author-item"><a href="https://segmentfault.com/u/zehao" target="_blank" title="Segmentfault">Segmentfault</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JS"><span class="nav-number">1.</span> <span class="nav-text">JS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#js的继承实现"><span class="nav-number">1.1.</span> <span class="nav-text">js的继承实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建方式"><span class="nav-number">1.1.1.</span> <span class="nav-text">创建方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造器方法"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">构造器方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Object-create-es5"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Object.create (es5)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#class-es6"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">class (es6)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能"><span class="nav-number">1.1.2.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#js的闭包"><span class="nav-number">1.2.</span> <span class="nav-text">js的闭包</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#闭包的应用"><span class="nav-number">1.2.1.</span> <span class="nav-text">闭包的应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#性能问题"><span class="nav-number">1.2.2.</span> <span class="nav-text">性能问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#“use-strict”"><span class="nav-number">1.3.</span> <span class="nav-text">“use strict”;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#声明方式"><span class="nav-number">1.3.1.</span> <span class="nav-text">声明方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#区别"><span class="nav-number">1.3.2.</span> <span class="nav-text">区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#语法错误"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">语法错误</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#语义差异"><span class="nav-number">1.3.3.</span> <span class="nav-text">语义差异</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#函数调用中的this"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">函数调用中的this</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#arguments对象属性不与对应的形参变量同步更新"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">arguments对象属性不与对应的形参变量同步更新</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eval相关的区别"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">eval相关的区别</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">1.4.</span> <span class="nav-text">this</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#全局上下文"><span class="nav-number">1.4.1.</span> <span class="nav-text">全局上下文</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数上下文"><span class="nav-number">1.4.2.</span> <span class="nav-text">函数上下文</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#直接调用"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">直接调用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对象方法中的-this"><span class="nav-number">1.4.3.</span> <span class="nav-text">对象方法中的 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造函数中的-this"><span class="nav-number">1.4.4.</span> <span class="nav-text">构造函数中的 this</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call-apply"><span class="nav-number">1.4.5.</span> <span class="nav-text">call / apply</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind"><span class="nav-number">1.4.6.</span> <span class="nav-text">bind</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事件委托"><span class="nav-number">1.5.</span> <span class="nav-text">事件委托</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#阻止继续冒泡"><span class="nav-number">1.5.1.</span> <span class="nav-text">阻止继续冒泡</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AMD-CMD-UMD"><span class="nav-number">1.6.</span> <span class="nav-text">AMD/CMD/UMD</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSS"><span class="nav-number">2.</span> <span class="nav-text">CSS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#盒子模型"><span class="nav-number">2.1.</span> <span class="nav-text">盒子模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#box-sizing"><span class="nav-number">2.1.1.</span> <span class="nav-text">box-sizing</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#content-box"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">content-box</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#border-box"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">border-box</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#position有哪些属性，各自是什么特点？"><span class="nav-number">2.2.</span> <span class="nav-text">position有哪些属性，各自是什么特点？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#static"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">static</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#relative"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">relative</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#absolute"><span class="nav-number">2.2.0.3.</span> <span class="nav-text">absolute</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fixed"><span class="nav-number">2.2.0.4.</span> <span class="nav-text">fixed</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sticky"><span class="nav-number">2.2.0.5.</span> <span class="nav-text">sticky</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垂直居中"><span class="nav-number">2.3.</span> <span class="nav-text">垂直居中</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#table"><span class="nav-number">2.3.1.</span> <span class="nav-text">table</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#绝对定位"><span class="nav-number">2.3.2.</span> <span class="nav-text">绝对定位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#行高（单行文本）"><span class="nav-number">2.3.3.</span> <span class="nav-text">行高（单行文本）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flex"><span class="nav-number">2.3.4.</span> <span class="nav-text">flex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JS-1"><span class="nav-number">2.3.5.</span> <span class="nav-text">JS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#圣杯布局"><span class="nav-number">2.4.</span> <span class="nav-text">圣杯布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#flex-1"><span class="nav-number">2.5.</span> <span class="nav-text">flex</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#grid"><span class="nav-number">2.6.</span> <span class="nav-text">grid</span></a></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#HTML"><span class="nav-number">3.</span> <span class="nav-text">HTML</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Style标签放置的最佳位置"><span class="nav-number">3.1.</span> <span class="nav-text">Style标签放置的最佳位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见行内元素和块级元素"><span class="nav-number">3.2.</span> <span class="nav-text">常见行内元素和块级元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTML5-新增标签"><span class="nav-number">3.3.</span> <span class="nav-text">HTML5 新增标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Doctype"><span class="nav-number">3.4.</span> <span class="nav-text">Doctype</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#浏览器"><span class="nav-number">4.</span> <span class="nav-text">浏览器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IE和Chrome事件模型的区别"><span class="nav-number">4.1.</span> <span class="nav-text">IE和Chrome事件模型的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cookie和session区别"><span class="nav-number">4.2.</span> <span class="nav-text">cookie和session区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#浏览器缓存策略"><span class="nav-number">4.3.</span> <span class="nav-text">浏览器缓存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HTTP-缓存"><span class="nav-number">4.3.1.</span> <span class="nav-text">HTTP 缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#HTML5-manifest"><span class="nav-number">4.3.2.</span> <span class="nav-text">HTML5 manifest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#localStorage"><span class="nav-number">4.3.3.</span> <span class="nav-text">localStorage</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Service-Worker"><span class="nav-number">4.3.4.</span> <span class="nav-text">Service Worker</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP"><span class="nav-number">5.</span> <span class="nav-text">HTTP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理跨域的方法"><span class="nav-number">5.1.</span> <span class="nav-text">处理跨域的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Iframe-document-domain"><span class="nav-number">5.1.1.</span> <span class="nav-text">Iframe + document.domain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#有src的标签-统计代码"><span class="nav-number">5.1.2.</span> <span class="nav-text">有src的标签(统计代码)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSONP"><span class="nav-number">5.1.3.</span> <span class="nav-text">JSONP</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#跨域资源共享（CORS）"><span class="nav-number">5.1.4.</span> <span class="nav-text">跨域资源共享（CORS）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见HTTP状态码"><span class="nav-number">5.2.</span> <span class="nav-text">常见HTTP状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GET和POST的区别"><span class="nav-number">5.3.</span> <span class="nav-text">GET和POST的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#url请求的过程"><span class="nav-number">5.4.</span> <span class="nav-text">url请求的过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器技术"><span class="nav-number">6.</span> <span class="nav-text">服务器技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#websocket"><span class="nav-number">6.1.</span> <span class="nav-text">websocket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#框架"><span class="nav-number">7.</span> <span class="nav-text">框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#antdesign"><span class="nav-number">7.1.</span> <span class="nav-text">antdesign</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#React的diff原理和组件化思想"><span class="nav-number">7.2.</span> <span class="nav-text">React的diff原理和组件化思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#state-props"><span class="nav-number">7.3.</span> <span class="nav-text">state / props</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f7优缺点"><span class="nav-number">7.4.</span> <span class="nav-text">f7优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#node版本的区别"><span class="nav-number">7.5.</span> <span class="nav-text">node版本的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#angularjs-脏检查"><span class="nav-number">7.6.</span> <span class="nav-text">angularjs 脏检查</span></a></li></ol></li></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2017</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Zehao Zhang</span> <a href="http://www.miibeian.gov.cn/" target="_blank">沪ICP备16039653号</a></div><div class="powered-by">由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script></body></html>